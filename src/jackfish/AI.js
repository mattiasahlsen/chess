/**
 * @module AI
 * The "AI", or computer mover.
 * @flow
 */

import Position, { A1, H8 } from './Position';
import { Cwf } from './tp'
import { PIECE } from './evaluation';

import type { Move, Piece } from './declarations';

// best moves for a position in reverse order
type Pv = Array<[Move, Piece]>;

// Constants and types.
// If value of position is > this, it means previous move was invalid
const MAX_SCORE = 15 * PIECE.Q; // with margin
const SEARCH_MARGIN = 100;

// fail low, high, hit exact (between alpha and beta) or invalid position
const L = 'L';
const E = 'E';
const H = 'H';
const I = 'I';

type Entry = {
  pv: Pv, // moves previously beat alpha, from worst to best
  score: number,
  depth: number,
  fail: 'L' | 'E' | 'H'
};

const tp: Cwf<Entry> = new Cwf(1e6);

// Logs
let tpHits = 0;

// Helper functions

// Calls a callback function for all moves (as arguments) generated by genMoves,
// including all 4 promotion moves for promotions. Runs through pv moves first.
// if callback returns true, breaks
function forMoves(pos: Position, pv: Pv,
  callback: (move: Move, promo?: Piece) => boolean): void {
  for (let i = pv.length - 1; i >= 0; i--) {
    if (callback(pv[i][0], pv[i][1])) return; // move, promo
  }

  const moves = pos.genMoves();
  let el = moves.next();
  while (!el.done) {
    const move = el.value;
    if (pos.board[move[0]] === 'P' && move[1] <= H8) {
      const promos = 'QNRB';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any))) return;
      }
    } else if (pos.board[move[0]] === 'p' && move[1] >= A1) {
      const promos = 'qnrb';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any))) return;
      }
    } else if (callback(move)) return;
    el = moves.next();
  }
}

// Main algorithm

function alphaBeta(
  pos: Position,
  depth: number,
  alpha: number,
  beta: number,
  root: boolean = false): number {
  if (depth < 0) depth = 0;
  let pv = []; // default

  // look up in tp
  let entry: any = tp.get(pos.hash);
  if (entry) {
    pv = entry.pv;
    if (entry.depth >= depth) {
      tpHits++;
      switch (entry.fail) {
        case L:
          if (entry.score <= alpha) return alpha;
          break;
        case E:
          return Math.min(Math.max(entry.score, alpha), beta)
        case H:
          if (entry.score >= beta) return beta
          break;
        case I: // invalid position, previous move was invalid
          return beta; // cause beta cutoff
        default: break;
      }
    }
  }

  // renew entry, use the previous pv as default
  entry = (tp.add(pos.hash,
    { pv: pv, score: alpha, depth: depth, fail: L }): Entry);

  // Callback helper
  const handleMove = (move, promo, score) => {
    if (score > alpha) {
      // if this is the first move to not raise alpha, reset pv
      if (entry.fail === L) entry.pv = [];

      entry.pv.push([move, promo]);
      if (score >= beta) {
        alpha = beta;
        entry.fail = H;
        return true;
      } else {
        alpha = score;
        entry.fail = E;
      }
    }
    return false;
  };

  // quiescence search ( 2 * PIECE.P (200 centipawns) is the margin)
  if (depth === 0) {
    // null move beta cutoff
    if (pos.score >= beta) {
      entry.score = beta;
      entry.fail = H;
      return beta;
    } else if (pos.score > alpha) {
      // expect all moves in quiescence search to raise alpha, so this is
      // the minimum value
      entry.fail = E;
      alpha = pos.score;
    } else if (pos.score + PIECE.Q < alpha) return alpha; // delta pruning

    forMoves(pos, pv, (move, promo) => {
      // don't test silent moves
      if (!pos.board[move[1]] && move[1] !== pos.ep) return false;

      const nextScore = pos.score + pos.value(move, promo);
      if (nextScore >= MAX_SCORE) {
        entry.fail = I;
        alpha = beta;
        return true;
      }

      // delta pruning
      if ((pos.board[move[1]] || move[1] === pos.ep) && nextScore + 2 * PIECE.P >= alpha) {
        // passes margin and not silent positon, search deeper
        return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), 0, -beta, -alpha));
      }
      return false; // let forMoves() keep running
    })
  } else {
    // depth >= 1

    // futiity pruning
    if (depth === 1 && pos.score + PIECE.Q < alpha) return alpha;

    // don't do nullmove at root
    let score;
    if (!root) {
      score = -alphaBeta(pos.nullMove(), depth - 3, -beta, -alpha);
      if (score >= beta) {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    }

    forMoves(pos, pv, (move, promo) => {
      const nextScore = pos.score + pos.value(move, promo);
      if (nextScore >= MAX_SCORE) {
        alpha = beta;
        entry.fail = I;
        return true; // cause beta cutoff
      }
      // futility pruning
      if (depth === 1 && nextScore + 2 * PIECE.P < alpha) return false;

      return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), depth - 1, -beta, -alpha));
    });
  }

  // alpha should have been changed to beta on beta cutoff
  entry.score = alpha;
  return alpha;
}

function mtdf(pos: Position, depth: number, guess: number): number {
  const bound = { lower: -MAX_SCORE, upper: MAX_SCORE };
  let beta;
  let f = guess;
  let margin = SEARCH_MARGIN;

  do {
    // find a window of size margin, then do a binary search in it
    if (bound.lower !== -MAX_SCORE && bound.upper !== MAX_SCORE) {
      if (bound.upper - bound.lower > 3) beta = Math.floor((bound.lower + bound.upper) / 2);
      else beta = f + (f === bound.lower ? 1 : 0);
    } else if (f === bound.lower) beta = f + margin;
    else if (f === bound.upper) beta = f - margin;
    else beta = f;

    f = alphaBeta(pos, depth, beta - 1, beta, true);

    if (f < beta) bound.upper = f;
    else bound.lower = f;
  } while (bound.lower <= bound.upper - 1); // - 0.01 for floating point inaccuracy

  return f;
}

// assumes there are valid moves
export default function move(pos: Position): [Move, Piece] | null {
  let score = pos.score;
  // iterative deepening
  for (let i = 1; i < 4; i++) {
    score = mtdf(pos, i, score)
    console.log('depth:' + i + ', size: ' + tp.size());
  }

  // should always be a hit
  const entry = tp.get(pos.hash);

  console.log('hits: ' + tpHits + '\n');
  tpHits = 0;
  tp.clear();

  if (entry && entry.pv.length > 0) return entry.pv[entry.pv.length - 1];
  else return null;
}
