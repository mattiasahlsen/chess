/**
 * @module AI
 * The "AI", or computer mover.
 * @flow
 */

import Position, { A1, H8 } from './Position';
import { Cwf } from './tp'
import { PIECE } from './evaluation';
import { next } from './helpers';
import { PIECES } from './declarations';

import type { Move, Piece, History, Hash } from './declarations';

// best moves for a position in reverse order
type Pv = [Move, Piece | void] | void;

// Constants and types.

// If value of position is > this, it means previous move was invalid
const MAX_SCORE = 15 * PIECE.Q; // with margin
// How much to move alpha and beta in the mtd(f) until we have failed
// both high and low
const SEARCH_MARGIN = 50;

// fail low, high, hit exact (between alpha and beta) or invalid position
const L = 'L';
const E = 'E';
const H = 'H';

type Entry = {
  pv: Pv, // moves previously beat alpha, from worst to best
  score: number,
  depth: number,
  fail: 'L' | 'E' | 'H'
};

const tp: Cwf<Entry> = new Cwf(1e7);
const boardTable: any = new Cwf(1e3); // table to find repeated positions

// add methods to boardTable
boardTable.push = function(hash: Hash) {
  let count = this.get(hash); // if this position has been visited before
  if (count !== undefined) this.add(hash, count + 1);
  else this.add(hash, 1);
}
boardTable.pull = function(hash: Hash) {
  let count = this.get(hash); // if this position has been visited before
  if (count !== undefined && count > 0) this.add(hash, count - 1);
}

/* eslint-disable */
// Data structure for storing killer moves (not pawn promotions)
class Killer {
  origins: { [number]: { [number]: boolean } } = {};
  constructor() {
    return this;
  }

  add(move: Move) {
    if (this.origins[move[0]]) this.origins[move[0]][move[1]] = true;
    else {
      this.origins[move[0]] = {};
      this.origins[move[0]][move[1]] = true;
    }
  }

  forEach(pos, callBack: (move: Move, tp: ?Piece) => boolean) {
    for (const o in this.origins) {
      for (const t in this.origins[o]) {
        // TODO: Implement pseudo valid method on Position class and use
        // here, then if it is pseudo-valid, call callback with the move
      }
    }
  }
}
/* eslint-enable */

// Logs
let tpHits = 0;
let searched = 0; // how many positions searched

let timeLimit;
let gotMove = false; // must have failed high or exact once to get a move
const timeout = () => Date.now() > timeLimit && gotMove;

// Helper functions

// Calls a callback function for all moves (as arguments) generated by genMoves,
// including all 4 promotion moves for promotions. Runs through pv moves first.
// if callback returns true, breaks. Returns true if there were any moves
// generated, else false.
function forMoves(pos: Position, pv: Pv,
  callback: (move: Move, promo?: Piece, tp: ?Piece) => boolean): void {
  if (pv) {
    const move = pv[0];
    let tp;
    if (move[1] === pos.ep) {
      if (pos.board[move[0]] === 'P') tp = pos.board[pos.ep + 8];
      else if (pos.board[move[0]] === 'p') tp = pos.board[pos.ep - 8];
      else tp = pos.board[move[1]];
    } else tp = pos.board[move[1]];

    if (callback(pv[0], pv[1], tp)) return; // move, promo
  }

  const moves = pos.genMoves();
  let el = moves.next();
  if (el.done) return; // if there are no valid moves

  while (!el.done) {
    const move = el.value;
    let tp;
    if (move[1] === pos.ep) {
      if (pos.board[move[0]] === 'P') tp = pos.board[pos.ep + 8];
      else tp = pos.board[pos.ep - 8];
    } else tp = pos.board[move[1]];

    if (pos.board[move[0]] === 'P' && move[1] <= H8) {
      const promos = 'QNRB';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any), tp)) return;
      }
    } else if (pos.board[move[0]] === 'p' && move[1] >= A1) {
      const promos = 'qnrb';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any), tp)) return;
      }
    } else if (callback(move, undefined, tp)) return;
    el = moves.next();
  }
}

// Check if a positino is stalemate. Assumes nobody is in check.
// Promotion piece doesn't matter.
function inStalemate(pos: Position) {
  const moves = pos.genMoves();
  let el = moves.next();
  while (!el.done) {
    // don't try castling, if the castle is valid, there is also a valid
    // king move that don't gets you in check
    // $FlowFixMe
    if ('Kk'.includes(pos.board[el.value[0]]) && Math.abs(el.value[1] - el.value[0]) === 2) {
      el = moves.next();
      continue;
    }

    // if a move didn't get your king killed
    if (!pos.move(el.value).inCheck(pos.turn)) {
      return false; // not stalemate
    }
    el = moves.next();
  }
  return true; // stalemate
}

export function getPieces(pos: Position) {
  const pieces: Object = {};
  PIECES.forEach((e) => { pieces[e] = 0 });
  for (let i = 0; i < 64; i++) {
    const p = pos.board[i];
    if (p) pieces[p]++;
  }
  pieces.new = function(takenPiece?: Piece) {
    const newPieces = Object.assign({}, this);
    if (takenPiece) newPieces[takenPiece]--;
    return newPieces;
  }
  pieces.endgame = function() {
    if (this.Q > 0) {
      if (this.R > 0 || this.B + this.N > 1) return false;
    }
    if (this.q > 0) {
      if (this.r > 0 || this.b + this.n > 1) return false;
    }
    return true;
  }
  pieces.insufficientMaterial = function() {
    return this.Q === 0 && this.q === 0 &&
      this.P === 0 && this.p === 0 &&
      this.R === 0 && this.r === 0 &&
      (this.B === 0 || (this.B === 1 && this.N === 0)) &&
      (this.b === 0 || (this.b === 1 && this.n === 0));
  }

  return pieces;
}

// Main algorithm

// generic alpha-beta algorithm, doesn't assume mtd(f) search
function alphaBeta(
  pos: Position,
  depth: number,
  alpha: number,
  beta: number,
  pieces: Object,
  root: boolean = false): number {
  searched++;
  if (depth < 0) depth = 0;

  // draw
  if (pos.halfMoveClock >= 50) {
    return 0;
  }
  if (boardTable.get(pos.boardHash) >= 3) {
    return 0;
  }

  let stalemate = true; // true until proven otherwise
  let pv: Pv; // default

  // look up in tp
  let entry: any = tp.get(pos.hash); // previous entry
  if (entry) {
    pv = entry.pv;
    if (entry.depth >= depth) {
      tpHits++;
      switch (entry.fail) {
        case L:
          if (entry.score <= alpha) return alpha;
          break;
        case E:
          return entry.score;
        case H:
          if (entry.score >= beta) return beta
          break;
        default: break;
      }
    }
  }

  // renew entry, use the previous pv as default
  entry = (tp.add(pos.hash,
    { pv: pv, score: alpha, depth: depth, fail: L }): Entry);

  // Determine if we're in endgame.
  // Endgame begins when any side that has a queen has one other minorpiece maximum.
  // Disable delta pruning, change king pst and look for stalemates.
  const endgame: boolean = pieces.endgame();
  if (endgame && pieces.insufficientMaterial()) {
    entry.score = 0;
    entry.fail = E;
    return 0;
  }

  // Callback helper
  const handleMove = (move, promo?, score) => {
    // if time's out
    if (timeout()) return true;

    // must be a beta cutoff since it's a null window search
    if (score > alpha) {
      entry.fail = H
      stalemate = false; // my move was valid
      entry.pv = [move, promo]; // new pv

      if (score >= MAX_SCORE) alpha = MAX_SCORE;
      else alpha = beta;

      return true;
    } else if (score > -MAX_SCORE) stalemate = false; // if my move was valid
    return false;
  };

  // quiescence search ( 2 * PIECE.P (200 centipawns) is the margin)
  if (depth <= 0) {
    // null move beta cutoff
    if (pos.score >= beta) {
      // if no moves gets you out of check, this position will fail low
      if (pos.inCheck()) {
        stalemate = false;

        // test all moves
        forMoves(pos, pv, (move, promo, tp) => {
          // tp here is target piece, not transposition table
          const nextPos = pos.move(move, promo);
          // if this move got rid of the check threat (if the move after
          // can't take king)
          if (!nextPos.inCheck(pos.turn)) {
            boardTable.push(nextPos.boardHash);
            const score = -alphaBeta(nextPos, 0, -beta, -alpha, pieces.new(tp));
            boardTable.pull(nextPos.boardHash);
            return handleMove(move, promo, score);
          } else return false;
        });
      } else if (endgame && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      } else {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    } else if (pos.score + PIECE.Q < alpha) {
      if (pos.inCheck(next(pos.turn))) {
        entry.fail = H;
        entry.score = MAX_SCORE;
        return MAX_SCORE; // king take or invalid castle
      } else if (endgame && !pos.inCheck() && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      }
      // Might wanna try moves that check here later.

      return alpha; // delta pruning
    } else {
      forMoves(pos, pv, (move, promo, tp) => {
        // check if there was an invalid castle (saves time to do it here)
        if (pos.kp !== -1 && Math.abs(pos.kp - move[1]) < 2) {
          alpha = MAX_SCORE;
          entry.fail = H;
          return true;
        }

        // don't test silent moves
        if (!pos.board[move[1]] && !(move[1] === pos.ep &&
          'Pp'.includes((pos.board[move[0]]: any)))) return false;

        const nextScore = pos.score + pos.value(move, promo);
        // check if it's a king-take move, if it is we save a lot of time
        if (nextScore >= MAX_SCORE) {
          alpha = MAX_SCORE;
          entry.fail = H;
          return true;
        }

        // delta pruning
        if ((pos.board[move[1]] || move[1] === pos.ep) && nextScore + 2 * PIECE.P >= alpha) {
          // passes margin and not silent positon, search deeper
          const nextPos = pos.move(move, promo, -nextScore);
          boardTable.push(nextPos.boardHash);
          const score = -alphaBeta(nextPos, 0, -beta, -alpha, pieces.new(tp));
          boardTable.pull(nextPos.boardHash);
          return handleMove(move, promo, score);
        }
        return false; // let forMoves() keep running
      });
      // if stalemate is still true, we know no valid moves were tested,
      // but we don't know if there were no valid moves
      // and therefore we should just return the score of this position
      if (stalemate && alpha < beta) {
        entry.fail = E;
        entry.score = pos.score;
        return pos.score;
      }
    }
  } else {
    // depth >= 1

    // futiity pruning (use when searching deeper, not yet, need
    // to watch out for king-take moves)
    if (!root && depth === 1 && pos.score + PIECE.Q < alpha) {
      if (pos.inCheck(next(pos.turn))) {
        entry.score = MAX_SCORE;
        entry.fail = H
        return MAX_SCORE; // if you can take king
      } else if (endgame && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      }
      return alpha;
    }

    // don't do nullmove at root or in endgame
    // if in check, will not fail high
    let score;
    if (!root && !endgame) {
      score = -alphaBeta(pos.nullMove(), depth - 3, -beta, -alpha, pieces.new());
      if (score >= beta) {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    }

    forMoves(pos, pv, (move, promo) => {
      const nextScore = pos.score + pos.value(move, promo);
      // check if it's a king-take move or if the previous move was an invalid
      // castle, if it is we save a lot of time
      if (nextScore >= MAX_SCORE) {
        alpha = MAX_SCORE;
        entry.fail = H;
        return true;
      }

      if (depth === 1 && nextScore + 2 * PIECE.P < alpha) return false;

      const nextPos = pos.move(move, promo, -nextScore);
      boardTable.push(nextPos.boardHash);
      const score = -alphaBeta(nextPos, depth - 1, -beta, -alpha, pieces.new());
      boardTable.pull(nextPos.boardHash);
      return handleMove(move, promo, score);
    });
  }

  if (stalemate && endgame) {
    if (!pos.inCheck() && inStalemate(pos)) {
      entry.score = 0;
      entry.fail = E;
      return 0;
    }
  }

  // could only have gotten a better score, we got interrupted
  if (timeout()) {
    entry.fail = H;
  }

  // alpha should have been changed to beta on beta cutoff
  entry.score = alpha;
  return alpha;
}

// return bound in case of timeout
function mtdf(pos: Position, depth: number, guess: number): [number, number] {
  const bound = { lower: -MAX_SCORE, upper: MAX_SCORE };
  let f = guess;
  let beta = f - 2 * SEARCH_MARGIN; // start lower to fail high earlier

  const pieces = getPieces(pos);

  do {
    // find a window of size margin, then do a binary search in it
    if (bound.lower !== -MAX_SCORE && bound.upper !== MAX_SCORE) {
      if (bound.upper - bound.lower > 3) beta = Math.floor((bound.lower + bound.upper) / 2);
      else beta = f + (f === bound.lower ? 1 : 0);
    } else if (f === bound.lower) beta = f + SEARCH_MARGIN;
    else if (f === bound.upper) beta = f - SEARCH_MARGIN;

    f = alphaBeta(pos, depth, beta - 1, beta, pieces.new(), true);

    if (f < beta) bound.upper = f;
    else {
      bound.lower = f;
      gotMove = true;
    }
  } while (bound.lower <= bound.upper - 1 && !timeout()); // - 0.01 for floating point inaccuracy

  return [bound.lower, bound.upper];
}

// Assumes there are valid moves.
// @param time How many milliseconds to think. Min: 1000 Max. 60000
// @returns [move, promo, stopReason]
export default async function move(pos: Position,
  history: History,
  time: number = 5000,
  maxDepth: number = 100,
  logs: Object,
  betweenDepths?: () => Promise<any>): Promise<[Move, Piece | void, 'time' | 'depth']> {
  let score = pos.score;
  let bound;
  let entry: any;

  if (maxDepth < 1) maxDepth = 1;

  // set up position table (for three-repeat rule)
  history.forEach(e => {
    boardTable.push(new Position(e.fen).boardHash);
  });
  boardTable.push(pos.boardHash);

  if (time < 1000) time = 1000;
  if (time > 60000) time = 60000

  // timeLimit and timeOut() is defined globally higher up
  timeLimit = Date.now() + time; // run for 5 sec

  // reset logging information
  logs.searched = 0;
  logs.tpHits = 0;

  // iterative deepening, start at depth 1
  let i = 1;
  while (i <= maxDepth && !timeout()) {
    logs.depth = i;
    if (betweenDepths) await betweenDepths();

    // get the tp entry from the previous depth
    if (i > 1) entry = tp.get(pos.hash);
    bound = mtdf(pos, i, score);
    // lower bound and upper bound will always be the same unless interrupted
    score = bound[0];
    i++;
    logs.searched = searched;
    logs.tpHits = tpHits;
  }
  const stopReason = timeout() ? 'time' : 'depth';
  gotMove = false; // reset this
  searched = 0;
  tpHits = 0;

  // compare entry from the latest depth (that got interrupted)
  // to the entry from the depth before to see which one is best
  const deepestEntry: any = tp.get(pos.hash); // should always be a hit
  // if we didn't even finish depth 1, entry won't be defined
  if (!entry ||
    ((bound: any)[0] > entry.score) || // means we got a better move
    ((bound: any)[1] < entry.score) // means the move we have is worse than we thought
  ) entry = deepestEntry;

  // clear transposition table between depths
  tp.clear();
  boardTable.clear();
  const returnVal = entry.pv;
  returnVal.push(stopReason);
  return returnVal;
}
