/**
 * @module AI
 * The "AI", or computer mover.
 * @flow
 */

import Engine from './';
import Position, { A1, H8 } from './Position';
import { Cwf } from './tp'
import { PIECE } from './evaluation';
import { next } from './helpers';

import { PIECES } from './declarations';
import type { Move, Piece } from './declarations';

// best moves for a position in reverse order
type Pv = Array<[Move, Piece]>;

// Constants and types.

// If value of position is > this, it means previous move was invalid
const MAX_SCORE = 15 * PIECE.Q; // with margin
// How much to move alpha and beta in the mtd(f) until we have failed
// both high and low
const SEARCH_MARGIN = 50;

// fail low, high, hit exact (between alpha and beta) or invalid position
const L = 'L';
const E = 'E';
const H = 'H';

type Entry = {
  pv: Pv, // moves previously beat alpha, from worst to best
  score: number,
  depth: number,
  fail: 'L' | 'E' | 'H'
};

const tp: Cwf<Entry> = new Cwf(1e7);

// Logs
let tpHits = 0;
let searched = 0; // how many positions searched

let timeLimit;
let gotMove = false; // must have failed high or exact once to get a move
const timeout = () => Date.now() > timeLimit && gotMove;

// Helper functions

// Calls a callback function for all moves (as arguments) generated by genMoves,
// including all 4 promotion moves for promotions. Runs through pv moves first.
// if callback returns true, breaks. Returns true if there were any moves
// generated, else false.
function forMoves(pos: Position, pv: Pv,
  callback: (move: Move, promo?: Piece, tp: ?Piece) => boolean): void {
  for (let i = pv.length - 1; i >= 0; i--) {
    const move = pv[i][0];
    let tp;
    if (move[1] === pos.ep) {
      if (pos.board[move[0]] === 'P') tp = pos.board[pos.ep + 8];
      else tp = pos.board[pos.ep - 8];
    } else tp = pos.board[move[1]];

    if (callback(pv[i][0], pv[i][1], tp)) return; // move, promo
  }

  const moves = pos.genMoves();
  let el = moves.next();
  if (el.done) return; // if there are no valid moves

  while (!el.done) {
    const move = el.value;
    let tp;
    if (move[1] === pos.ep) {
      if (pos.board[move[0]] === 'P') tp = pos.board[pos.ep + 8];
      else tp = pos.board[pos.ep - 8];
    } else tp = pos.board[move[1]];

    if (pos.board[move[0]] === 'P' && move[1] <= H8) {
      const promos = 'QNRB';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any), tp)) return;
      }
    } else if (pos.board[move[0]] === 'p' && move[1] >= A1) {
      const promos = 'qnrb';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any), tp)) return;
      }
    } else if (callback(move, undefined, tp)) return;
    el = moves.next();
  }
}

// Check if a positino is stalemate. Assumes nobody is in check.
// Promotion piece doesn't matter.
function inStalemate(pos: Position) {
  const moves = pos.genMoves();
  let el = moves.next();
  while (!el.done) {
    // don't try castling, if the castle is valid, there is also a valid
    // king move that don't gets you in check
    // $FlowFixMe
    if ('Kk'.includes(pos.board[el.value[0]]) && Math.abs(el.value[1] - el.value[0]) === 2) {
      el = moves.next();
      continue;
    }

    // if a move didn't get your king killed
    if (!pos.move(el.value).inCheck(pos.turn)) {
      return false; // not stalemate
    }
    el = moves.next();
  }
  return true; // stalemate
}

function getPieces(pos: Position) {
  const pieces: Object = {};
  PIECES.forEach((e) => { pieces[e] = 0 });
  for (let i = 0; i < 64; i++) {
    const p = pos.board[i];
    if (p) pieces[p]++;
  }
  pieces.new = function(takenPiece?: Piece) {
    const newPieces = Object.assign({}, this);
    if (takenPiece) newPieces[takenPiece]--;
    return newPieces;
  }
  pieces.endgame = function() {
    if (this.Q > 0) {
      if (this.R > 0 || this.B + this.N > 1) return false;
    }
    if (this.q > 0) {
      if (this.r > 0 || this.b + this.n > 1) return false;
    }
    return true;
  }
  pieces.insufficientMaterial = function() {
    return this.Q === 0 && this.q === 0 &&
      this.P === 0 && this.p === 0 &&
      this.R === 0 && this.r === 0 &&
      (this.B === 0 || (this.B === 1 && this.N === 0)) &&
      (this.b === 0 || (this.b === 1 && this.n === 0));
  }

  return pieces;
}

// Main algorithm

function alphaBeta(
  pos: Position,
  depth: number,
  alpha: number,
  beta: number,
  pieces: Object,
  root: boolean = false): number {
  searched++;
  let pv = []; // default

  if (pos.halfMoveClock >= 50) {
    // no point in saving an entry in transposition table
    return 0; // stalemate
  }
  let stalemate = true; // true until proven otherwise

  // look up in tp
  let entry: any = tp.get(pos.hash);
  if (entry) {
    pv = entry.pv;
    if (entry.depth >= depth) {
      tpHits++;
      switch (entry.fail) {
        case L:
          if (entry.score <= alpha) return alpha;
          break;
        case E:
          return Math.min(Math.max(entry.score, alpha), beta)
        case H:
          if (entry.score >= beta) return beta
          break;
        default: break;
      }
    }
  }

  // renew entry, use the previous pv as default
  entry = (tp.add(pos.hash,
    { pv: pv, score: alpha, depth: depth, fail: L }): Entry);

  // Determine if endgame.
  // Endgame begins when any side that has a queen has one other minorpiece maximum.
  // Disable delta pruning, change king pst and look for stalemates.
  const endgame: boolean = pieces.endgame();
  if (endgame && pieces.insufficientMaterial()) {
    entry.score = 0;
    entry.fail = E;
    return 0;
  }

  // Callback helper
  const handleMove = (move, promo, score) => {
    // if time's out
    if (timeout()) return true;

    if (score > alpha) {
      if (score >= MAX_SCORE) {
        alpha = MAX_SCORE;
        entry.fail = H
        return true;
      }
      stalemate = false; // my move was valid

      // if this is the first move to raise alpha, reset pv
      if (entry.fail === L) entry.pv = [];

      entry.pv.push([move, promo]);
      if (score >= beta) {
        alpha = beta;
        entry.fail = H;
        return true;
      } else {
        alpha = score;
        entry.fail = E;
      }
    } else if (score > -MAX_SCORE) stalemate = false; // if my move was valid
    return false;
  };

  // quiescence search ( 2 * PIECE.P (200 centipawns) is the margin)
  if (depth <= 0) {
    // null move beta cutoff
    if (pos.score >= beta) {
      // if no moves gets you out of check, this position will fail low
      if (pos.inCheck()) {
        stalemate = false;

        // test all moves
        forMoves(pos, pv, (move, promo, tp) => {
          const nextPos = pos.move(move, promo);
          // if this move got rid of the check threat (if the move after
          // can't take king)
          if (!nextPos.inCheck(pos.turn)) {
            return handleMove(move, promo, -alphaBeta(nextPos, depth - 1,
              -beta, -alpha, pieces.new(tp)));
          } else return false;
        });
      } else if (endgame && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      } else {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    } else if (pos.score + PIECE.Q < alpha) {
      if (pos.inCheck(next(pos.turn))) {
        entry.fail = H;
        entry.score = MAX_SCORE;
        return MAX_SCORE; // king take or invalid castle
      } else if (endgame && !pos.inCheck() && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      }
      return alpha; // delta pruning
    } else {
      forMoves(pos, pv, (move, promo, tp) => {
        // check if there was an invalid castle (saves time to do it here)
        if (pos.kp !== -1 && Math.abs(pos.kp - move[1]) < 2) {
          alpha = MAX_SCORE;
          entry.fail = H;
          return true;
        }

        // don't test silent moves
        if (!pos.board[move[1]] && move[1] !== pos.ep) return false;

        const nextScore = pos.score + pos.value(move, promo);
        // check if it's a king-take move, if it is we save a lot of time
        if (nextScore >= MAX_SCORE) {
          alpha = MAX_SCORE;
          entry.fail = H;
          return true;
        }

        // delta pruning
        if ((pos.board[move[1]] || move[1] === pos.ep) && nextScore + 2 * PIECE.P >= alpha) {
          // passes margin and not silent positon, search deeper
          return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), depth - 1, -beta, -alpha, pieces.new(tp)));
        }
        return false; // let forMoves() keep running
      });
    }
  } else {
    // depth >= 1

    // futiity pruning (use when searching deeper, not yet, need
    // to watch out for king-take moves)
    if (!root && depth === 1 && pos.score + PIECE.Q < alpha) {
      if (pos.inCheck(next(pos.turn))) {
        entry.score = MAX_SCORE;
        entry.fail = H
        return MAX_SCORE; // if you can take king
      } else if (endgame && inStalemate(pos)) {
        entry.score = 0;
        entry.fail = E;
        return 0;
      }
      return alpha;
    }

    // don't do nullmove at root or in endgame
    // if in check, will not fail high
    let score;
    if (!root && !endgame) {
      score = -alphaBeta(pos.nullMove(), depth - 3, -beta, -alpha, pieces.new());
      if (score >= beta) {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    }

    forMoves(pos, pv, (move, promo) => {
      const nextScore = pos.score + pos.value(move, promo);
      // check if it's a king-take move or if the previous move was an invalid
      // castle, if it is we save a lot of time
      if (nextScore >= MAX_SCORE) {
        alpha = MAX_SCORE;
        entry.fail = H;
        return true;
      }

      if (depth === 1 && nextScore + 2 * PIECE.P < alpha) return false;

      return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), depth - 1, -beta, -alpha, pieces.new()));
    });
  }

  if (stalemate && endgame) {
    if (!pos.inCheck() && inStalemate(pos)) {
      entry.score = 0;
      entry.fail = E;
      return 0;
    }
  }

  // could only have gotten a better score, we got interrupted
  if (timeout()) {
    entry.fail = H;
  }

  // alpha should have been changed to beta on beta cutoff
  entry.score = alpha;
  return alpha;
}

function mtdf(pos: Position, depth: number, guess: number): number {
  const bound = { lower: -MAX_SCORE, upper: MAX_SCORE };
  let beta;
  let f = guess - SEARCH_MARGIN; // start lower to fail high earlier

  const pieces = getPieces(pos);

  do {
    // find a window of size margin, then do a binary search in it
    if (bound.lower !== -MAX_SCORE && bound.upper !== MAX_SCORE) {
      if (bound.upper - bound.lower > 3) beta = Math.floor((bound.lower + bound.upper) / 2);
      else beta = f + (f === bound.lower ? 1 : 0);
    } else if (f === bound.lower) beta = f + SEARCH_MARGIN;
    else if (f === bound.upper) beta = f - SEARCH_MARGIN;
    else beta = f;

    f = alphaBeta(pos, depth, beta - 1, beta, pieces.new(), true);

    if (f < beta) bound.upper = f;
    else {
      bound.lower = f;
      gotMove = true;
    }
  } while (bound.lower <= bound.upper - 1 && !timeout()); // - 0.01 for floating point inaccuracy

  return f;
}

// Assumes there are valid moves.
// @param time How many milliseconds to think. Min: 1000 Max. 60000
export default function move(pos: Position, time: number = 5000): [Move, Piece] | null {
  let score = pos.score;
  let entry: any;
  if (time < 1000) time = 1000;
  if (time > 60000) time = 60000

  // timeLimit and timeOut() is defined globally higher up
  timeLimit = Date.now() + time; // run for 5 sec

  // iterative deepening
  let i = 1;
  while (i < 1000 && !timeout()) {
    // get the tp entry from the previous depth
    if (i > 1) entry = tp.get(pos.hash);
    score = mtdf(pos, i, score)
    console.log('depth:' + i + ', size: ' + tp.size());
    i++;
  }
  gotMove = false; // reset this

  // compare entry from the latest depth (that got interrupted most likely)
  // to the entry from the depth before to see which one is best
  const deepestEntry: any = tp.get(pos.hash);
  if (!entry || (deepestEntry.score > entry.score &&
    (deepestEntry.fail === H || deepestEntry.fail === E))) entry = deepestEntry;

  console.log('searched: ' + searched);
  console.log('hits: ' + tpHits + '\n');
  tpHits = 0;
  tp.clear();

  if (!entry) return null;
  while ((entry: any).pv.length > 0) {
    let move = (entry: any).pv.pop(); // [move, promo]
    if (pos.valid(move[0])) return move;
  }
  return null;
}
