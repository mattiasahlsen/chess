/**
 * @module AI
 * The "AI", or computer mover.
 * @flow
 */

import Position, { A1, H8 } from './Position';
import { Cwf } from './tp'
import { PIECE } from './evaluation';
import { next } from './helpers';

import type { Move, Piece } from './declarations';

// best moves for a position in reverse order
type Pv = Array<[Move, Piece]>;

// Constants and types.
// If value of position is > this, it means previous move was invalid
const MAX_SCORE = 15 * PIECE.Q; // with margin
const SEARCH_MARGIN = 50;

// fail low, high, hit exact (between alpha and beta) or invalid position
const L = 'L';
const E = 'E';
const H = 'H';
const I = 'I';

type Entry = {
  pv: Pv, // moves previously beat alpha, from worst to best
  score: number,
  depth: number,
  fail: 'L' | 'E' | 'H' | 'I'
};

const tp: Cwf<Entry> = new Cwf(1e7);

// Logs
let tpHits = 0;
let searched = 0; // how many positions searched

let timeLimit;
const timeout = () => Date.now() > timeLimit;

// Helper functions

// Calls a callback function for all moves (as arguments) generated by genMoves,
// including all 4 promotion moves for promotions. Runs through pv moves first.
// if callback returns true, breaks
function forMoves(pos: Position, pv: Pv,
  callback: (move: Move, promo?: Piece) => boolean): void {
  for (let i = pv.length - 1; i >= 0; i--) {
    if (callback(pv[i][0], pv[i][1])) return; // move, promo
  }

  const moves = pos.genMoves();
  let el = moves.next();
  while (!el.done) {
    const move = el.value;
    if (pos.board[move[0]] === 'P' && move[1] <= H8) {
      const promos = 'QNRB';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any))) return;
      }
    } else if (pos.board[move[0]] === 'p' && move[1] >= A1) {
      const promos = 'qnrb';
      for (let i = 0; i < promos.length; i++) {
        if (callback(move, (promos.charAt(i): any))) return;
      }
    } else if (callback(move)) return;
    el = moves.next();
  }
}

// Check if pos is an invalid position
function invalidPos(pos: Position) {
  if (pos.inCheck(next(pos.turn))) return true;
  return (pos.kp !== -1 && pos.inCheck(next(pos.turn), pos.kp));
}

// Main algorithm

function alphaBeta(
  pos: Position,
  depth: number,
  alpha: number,
  beta: number,
  root: boolean = false): number {
  searched++;
  let pv = []; // default

  // look up in tp
  let entry: any = tp.get(pos.hash);
  if (entry) {
    pv = entry.pv;
    if (entry.depth >= depth) {
      tpHits++;
      switch (entry.fail) {
        case L:
          if (entry.score <= alpha) return alpha;
          break;
        case E:
          return Math.min(Math.max(entry.score, alpha), beta)
        case H:
          if (entry.score >= beta) return beta
          break;
        case I: // invalid position, previous move was invalid
          return beta; // cause beta cutoff
        default: break;
      }
    }
  }

  // renew entry, use the previous pv as default
  entry = (tp.add(pos.hash,
    { pv: pv, score: alpha, depth: depth, fail: L }): Entry);

  // Callback helper
  const handleMove = (move, promo, score) => {
    // if time's out
    if (timeout()) return true;

    if (score > alpha) {
      if (score >= MAX_SCORE) {
        alpha = beta;
        entry.fail = I;
        return true;
      }
      // if this is the first move to raise alpha, reset pv
      if (entry.fail === L) entry.pv = [];

      entry.pv.push([move, promo]);
      if (score >= beta) {
        alpha = beta;
        entry.fail = H;
        return true;
      } else {
        alpha = score;
        entry.fail = E;
      }
    }
    return false;
  };

  // quiescence search ( 2 * PIECE.P (200 centipawns) is the margin)
  if (depth <= 0) {
    // null move beta cutoff
    if (pos.score >= beta) {
      if (pos.inCheck()) {
        // test all moves
        forMoves(pos, pv, (move, promo) => {
          const nextPos = pos.move(move, promo);
          // if this move got rid of the check threat (if the move after
          // can't take king)
          if (!nextPos.inCheck(pos.turn)) {
            return handleMove(move, promo, -alphaBeta(nextPos, depth - 1, -beta, -alpha));
          } else return false;
        })
      } else {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    } else if (pos.score + PIECE.Q < alpha) {
      if (invalidPos(pos)) {
        entry.fail = I;
        return beta; // king take or invalid castle
      }
      return alpha; // delta pruning
    } else {
      forMoves(pos, pv, (move, promo) => {
        // check if there was an invalid castle
        if (pos.kp !== -1 && Math.abs(pos.kp - move[1]) < 2) {
          alpha = beta;
          entry.fail = I;
          return true;
        }

        // don't test silent moves
        if (!pos.board[move[1]] && move[1] !== pos.ep) return false;

        const nextScore = pos.score + pos.value(move, promo);

        // delta pruning
        if ((pos.board[move[1]] || move[1] === pos.ep) && nextScore + 2 * PIECE.P >= alpha) {
          // passes margin and not silent positon, search deeper
          return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), depth - 1, -beta, -alpha));
        }
        return false; // let forMoves() keep running
      });
    }
  } else {
    // depth >= 1

    // futiity pruning (use when searching deeper, not yet, need
    // to watch out for king-take moves)
    /*if (!root && depth === 1 && pos.score + PIECE.Q < alpha) {
      if (pos.isCheck(next(pos.turn))) return alpha;
    }*/

    // don't do nullmove at root
    let score;
    if (!root) {
      score = -alphaBeta(pos.nullMove(), depth - 3, -beta, -alpha);
      // score is NaN, this if-statement will fail
      if (score >= beta) {
        entry.score = beta;
        entry.fail = H;
        return beta;
      }
    }

    forMoves(pos, pv, (move, promo) => {
      const nextScore = pos.score + pos.value(move, promo);
      // futility pruning
      if (depth === 1 && nextScore + 2 * PIECE.P < alpha) return false;

      return handleMove(move, promo, -alphaBeta(pos.move(move, promo, -nextScore), depth - 1, -beta, -alpha));
    });
  }

  // could only have gotten a better score, we got interrupted
  if (timeout()) {
    if (entry.fail !== I) entry.fail = H;
  }

  // alpha should have been changed to beta on beta cutoff
  entry.score = alpha;
  return alpha;
}

function mtdf(pos: Position, depth: number, guess: number): number {
  const bound = { lower: -MAX_SCORE, upper: MAX_SCORE };
  let beta;
  let f = guess;
  let margin = SEARCH_MARGIN;

  do {
    // find a window of size margin, then do a binary search in it
    if (bound.lower !== -MAX_SCORE && bound.upper !== MAX_SCORE) {
      if (bound.upper - bound.lower > 3) beta = Math.floor((bound.lower + bound.upper) / 2);
      else beta = f + (f === bound.lower ? 1 : 0);
    } else if (f === bound.lower) beta = f + margin;
    else if (f === bound.upper) beta = f - margin;
    else beta = f;

    f = alphaBeta(pos, depth, beta - 1, beta, true);

    if (f < beta) bound.upper = f;
    else bound.lower = f;
  } while (bound.lower <= bound.upper - 1 && !timeout()); // - 0.01 for floating point inaccuracy

  return f;
}

// assumes there are valid moves
export default function move(pos: Position): [Move, Piece] | null {
  let score = pos.score;
  let entry: any;

  // iterative deepening
  timeLimit = Date.now() + 5000; // run for 5 sec

  let i = 1;
  while (i < 1000 && !timeout()) {
    // get the tp entry from the previous depth
    if (i > 1) entry = tp.get(pos.hash);
    score = mtdf(pos, i, score)
    console.log('depth:' + i + ', size: ' + tp.size());
    i++;
  }

  // compare entry from the latest depth (that got interrupted most likely)
  // to the entry from the depth before to see which one is best
  const deepestEntry: any = tp.get(pos.hash);
  if (deepestEntry.score > (entry: any).score &&
    (deepestEntry.fail === H || deepestEntry.fail === E)) entry = deepestEntry;

  console.log('searched: ' + searched);
  console.log('hits: ' + tpHits + '\n');
  tpHits = 0;
  tp.clear();

  while ((entry: any).pv.length > 0) {
    let move = (entry: any).pv.pop(); // [move, promo]
    if (pos.valid(move[0])) return move;
  }
  return null;
}
